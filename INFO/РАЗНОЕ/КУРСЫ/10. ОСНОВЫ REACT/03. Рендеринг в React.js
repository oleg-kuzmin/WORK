// Из предыдущего урока вы узнали, как подключить React и начать его использовать.
// Теперь расскажем, как осуществляется рендеринг, а разметка из React-кода попадает в HTML.

// * React в браузере
// Мы уже вызывали функцию ReactDOM.render.
// Именно с неё начинается любой веб-проект на React. Напомним, как она выглядит:

ReactDOM.render(React.createElement("h1", null, "Привет, React!"), document.getElementById("root"));

// Функция принимает два аргумента.
// Первый — разметка, которую мы хотим поместить в корневой узел.
// Второй — указатель на DOM-узел, который будем использовать в качестве корневого.

// Детальнее разберём первый аргумент функции ReactDOM.render.
// Это вызов ещё одной функции React.createElement, но уже из библиотеки react. Она вызывается с тремя аргументами:
// 1. Названием результирующего HTML-тега.
// 2. Дополнительными свойствами, которые прикреплены к этому тегу. Это может быть CSS-идентификатор class или id либо другие свойства.
// 3. Содержимым, которое попадёт в HTML-тег. В данном случае это строка "Привет, React!". Содержимым может быть не только текст, но и другие элементы.

// После третьего аргумента могут идти и другие.
// Все они будут добавлены друг за другом внутрь создаваемого элемента, как если бы мы использовали метод appendChild.
// В следующих уроках подробнее расскажем об аргументах и их особенностях, а также наследовании и вложении элементов.

// А пока рассмотрим пример:
ReactDOM.render(
  React.createElement(
    "div",
    null,
    React.createElement("h1", null, "Текущее время:"),
    React.createElement("h2", null, new Date().toLocaleTimeString())
  ),
  document.getElementById("root")
);

// Этот код выведет в корневой узел такую разметку:
{
  /*
  <div>
    <h1>Текущее время:</h1>
    <h2>11:54:14</h2>
  </div>
*/
}

// Если обновлять страницу, таймер будет каждый раз показывать новое время.
// Правда сайт, который требует от пользователя постоянно нажимать F5, едва ли станет популярным.

// Реальные приложения порой состоят из десятков тысяч элементов.
// В случае изменения элемента на верхнем уровне все его потомки будут перерисованы.
// К сожалению, браузеры устроены так, что манипуляции с DOM — трудозатратные процессы для пользовательских устройств.
// При этом нагрузка на процессор, оперативную память и аккумулятор значительно вырастет.

// Как же React остаётся таким быстрым в этих условиях?
// Всё дело в хитрых механизмах оптимизации внутри библиотеки и VirtualDOM.
// React стремится изменять только тот кусок разметки, который нужно, и не трогать при этом остальной DOM.

// Допишем предыдущий пример, чтобы обновление счётчика происходило без перезагрузки страницы:

function timer() {
  const element = React.createElement(
    "div",
    null,
    React.createElement("h1", null, "Текущее время:"),
    React.createElement("h2", null, new Date().toLocaleTimeString())
  );
  ReactDOM.render(element, document.getElementById("root"));
}
setInterval(timer, 1000);

// Теперь раз в секунду будет вызываться функция timer, задача которой — рендерить DOM-дерево из нескольких узлов.
// Кажется, будто все элементы дерева будут отрендерены заново, раз в секунду, но это не так. Вот что происходит на самом деле:

// Обновляется только элемент h2, который содержит в себе new Date().toLocaleTimeString(), а остальные элементы дерева не перерисовываются.
// ReactDOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только необходимые изменения.

// Элементы React иммутабельны: после создания элемента невозможно изменить его потомков или атрибуты.
// При иммутабельности можно только пересоздать элементы, что позволяет избавиться от множества ошибок, которые возникают при создании пользовательских интерфейсов.
// В React элемент можно представить как кадр киноплёнки: он отражает состояние интерфейса в конкретный момент времени.
// В рамках курса вы ещё не раз столкнётесь с иммутабельностью.

// Вы уже знакомы с одним способом обновления интерфейса — созданием нового элемента через ReactDOM.render.
// На практике большинство приложений, написанных на React, вызывают ReactDOM.render только один раз — при инициализации.
// В этом курсе вы изучите и другие способы влияния на интерфейс.
// В следующем уроке расскажем о механизме, который позволяет обновить только изменившийся HTML-элемент — VirtualDOM.